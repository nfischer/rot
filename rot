#!/bin/bash

# A simple rot13 encrypter/decrypter with some testing to see if a file is
# encrypted or decrypted

encrStatus()
{
	# returns the following:
	# 0: The file is encrypted
	# 1: The file is NOT encrypted
	# 2: Cannot determine
	# 3: Internal error
	
	file="$1"

	if [ -z "$file" ]; then
		echo "Error: empty string passed as file name." >&2
		return 3
	elif [ ! -f $file ]; then
		echo "Error: $file could not be found." >&2
		return 3
	fi

	# file is good
	topper="$(head -n 1 $file)"

	if [ "$topper" = "unencrypted" ]; then
		return 1
	elif [ "$topper" = "harapelcgrq" ]; then
		# spells "unencrypted" in rot13
		return 0 # encrypted
	elif [ "$topper" = "<!DOCTYPE html>" ]; then
		return 1
	
	# default case
	else
		return 2
	fi
	# guaranteed to have already returned
}


## main ##

exiter=0 # exit status

if [ $# = 0 ]; then
	echo "No files passed as arguments." >&2
	exit 1
fi

# encrypt each file, check if valid
for inFile in $*; do
	if [ -z "$inFile" ]; then
		echo "Error: empty string passed as file name." >&2
		exiter=2
		continue # skip this file
	elif [ ! -f $inFile ]; then
		echo "Error: $inFile could not be found." >&2
		exiter=2
		continue # skip this file
	fi

	outFile="$inFile.r13"
	# encryption is simple
	tr [a-zA-Z] [n-za-mN-ZA-M] < $inFile > $outFile
	
	# check encryption status
	encrStatus $inFile
	inEncr=$?
	encrStatus $outFile
	outEncr=$?

	# 0: The file is encrypted
	# 1: The file is NOT encrypted
	# 2: Cannot determine
	# 3: Internal error

	if [ $inEncr = 3 ] || [ $outEncr = 3 ]; then
		# error
		exiter=2
		continue
	elif [ $inFile = 1 ]; then # easier to check for unencrypted
		echo "$inFile is now encrypted"
		# inFile is the proper name of outFile
	elif [ $outEncr = 1 ]; then
		echo "$inFile is no longer encrypted"
	fi
	
	## clean up ##
	rm $inFile
	mv $outFile $inFile # rename

done

exit $exiter
